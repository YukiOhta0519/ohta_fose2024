\documentclass[T,J]{fose}
\taikai{2024}

\usepackage [dvipdfmx] {graphicx} 
\usepackage{ascmac}
\usepackage{url}

\begin{document}

\title{マイクロサービスにおける\\コードクローンの言語間分析}
\setetitle{Cross-Language Analysis of Code Clones in Microservices}

\author{太田 悠希　吉田 則裕　崔 恩瀞　槇原 絵里奈　横井 一輝
\ejtitle{\etitle}
\shozoku{Yuki Ota, Norihiro Yoshida, Erina Makihara}{立命館大学}{Ritsumeikan University}
\shozoku{Eunjong Choi}{京都工芸繊維大学}{Kyoto Institute of Technology}
\shozoku{Kazuki Yokoi}{株式会社NTTデータグループ}{NTT DATA Group Corporation}
}

\Jabstract{
マイクロサービスとは，複雑なソフトウェアを相互に通信可能な小規模サービス群に分割するアーキテクチャスタイルである．
既存研究おいて，マイクロサービスの各サービスは小規模なプログラムで実現されているにもかかわらず，多くのサービスにコードクローンが含まれていることが報告されている．
また，それらコードクローンの同時修正が報告されており，マイクロサービスにおいてコードクローンが保守コストを増大させていることをわかっている．
しかし，既存研究が行った調査では，8個のみのプロジェクトに含まれるサービスを対象としており，それらサービスはすべてJavaで開発されている．
そのため，様々な言語で開発された多くのサービスを対象とした調査を行うと，Moらの調査とは大きく異なる結果が得られる可能性がある．
そこで本研究では，12言語で開発された284個のプロジェクトを対象としてマイクロサービスに含まれるコードクローンの調査を行った．
その結果，JavaとC\#は，プログラム全体におけるコードクローンの割合や，複数のコードクローンが同時に修正されるものの割合が高いことがわかった．}
\Eabstract{}

\maketitle \thispagestyle {empty}

\section{はじめに}

マイクロサービスとは，複雑なソフトウェアを相互に通信可能な小規模サービス群に分割するアーキテクチャスタイルである\cite{Honda2023,mo2021existence,zhao2022}．
マイクロサービスの特徴の1つは，疎結合なサービス群に分割することで，各サービスの開発やデプロイ，保守を独立して行うことができることである\cite{mo2021existence,zhao2022}．

マイクロサービスを採用したプロジェクトにおいて，モジュール性を考慮しながら小規模サービス群に分割されているのであれば，各サービスに含まれるコードクローンは少ないことが予想される．
しかし，Moらの研究では，対象としたサービスの多くにコードクローンが含まれていることが報告されている\cite{mo2021existence}．
また，それらコードクローンの同時修正が報告されており，マイクロサービスにおいてコードクローンが保守コストを増大させていることをわかっている\cite{mo2021existence}．
マイクロサービスでは，各サービスを独立して開発できるため，各サービスはJavaだけでなく様々な言語で開発されているにもかかわらず，Moらの調査対象はJavaで開発されたサービスのみである．
マイクロサービスにおけるコードクローンに関して，より一般性の高い実証的研究を行うためには，対象言語を拡大して調査を行う必要がある．
%そのため，マイクロサービスに含まれるコードクローンについて，大規模な調査を行い，
%マイクロサービスでは，各サービスを独立して開発できるため，各サービスはJavaだけでなく様々な言語で開発されている（表\ref{table:detectLanguages}参照）．
%そのため，対象言語を拡大した

本研究では，d'Aragonaらが収集したマイクロサービスの大規模データセット\cite{amoroso2024dataset}を対象として，クローン率や同時修正率に関して言語間分析を行った．
本稿において，クローン率はプログラム全体に対するコードクローンの割合を指し，同時修正率は全クローンセット（\ref{subsec:clone}節参照）のうちの同時修正されるものの割合を指す．
分析対象の284個のOSSプロジェクトは，Javaを含む12言語\footnote{CとC++は，1つの言語として数えている．この理由は，本研究で使用したコードクローン検出ツールであるCCFinderSWが，これらを1つの言語として扱うからである．}で記述されている．
言語ごとにテストフレームワークが異なることから，テストコードのクローン率や同時修正率が言語間で異なると考え，プロダクトコードとテストコードを分けて，分析を行った．
本分析では，以下の3つのRQを設定した．
\begin{description}
    \item[RQ1：] クローン率が高い言語はどれか？
    \item[RQ2：] プロダクトコードとテストコード間でクローン率に差異はあるか？
    \item[RQ3：] コードクローンに対する同時修正率が高い言語はどれか？
\end{description}
12言語で記述されたプログラムに対してコードクローン検出を行うため，容易に対応言語を増やすことが検出ツールであるCCFinderSW\cite{CCFinderSW}を用いた．CCFinderSWは，CCFinder\cite{CCFinder}と同じくトークン列の等価性に基づくType-2クローン（\ref{subsec:clone}節参照）を検出する．
分析結果の概要を以下に示す．
\begin{itemize}
    \item JavaとC\#はクローン率と同時修正率の両者が高く，これら言語で記述されたサービスは，コードクローンにより保守性が低下していると考えられる．
    \item 言語間でクローン率や同時修正率が大きく異なるため，コードクローンが保守性に与える影響は言語ごとに異なると考えられる．
    \item プロダクトコードとテストコード間で，クローン率や同時修正率に有意差がある言語が存在した．このため，同一言語であってもテストコードかどうかで，コードクローンが保守性に与える影響は異なると考えられる．
\end{itemize}

以降，2章においてコードクローンやマイクロサービスに関する関連研究を述べ，3章では対象プロジェクトや言語を選定するための予備調査について述べる．その後，4章と5章において，それぞれ分析と結果を説明する．6章で分析結果と本調査の制限等について考察を行い，最後に7章で本稿をまとめる．

%マイクロサービスとは、複雑なソフトウェアを、軽量なメカニズムを使用して相互に通信する一連の小さく独立したサービスに分解するアーキテクチャスタイルである。マイクロサービス・アーキテクチャの本質は、サービスを疎結合にすることであり、その結果、サービスを独立して開発、保守、デプロイすることができる。サービスは互いに異なるプログラミング言語、技術的ソリューション、データベースを使用することもできる。したがって、各サービスは独立して開発、保守、デプロイされることになっている。

\section{関連研究}
\subsection{コードクローンとその検出ツール} \label{subsec:clone}


コードクローンとは，プログラム中に存在する互いに一致，または類似したコード片を指す\cite{コードクローン検出法}．
これまでに，トークン列や構文木の照合や深層学習に基づきコードクローンを検出する手法が数多く提案されてきている \cite{DECKARD,CCFinder,クローンタイプ,CCFinderSW,svajlenko2014evaluating,astnn}．
%一般的に，互いにコードクローンとなるコード片はクローンペアと呼ばれ，クローンペアにおいて同値関係が成り立つコードクローンの集合はクローンセットと呼ばれる．
互いにコードクローンとなる2つのコード片の組をクローンペアと呼び，コードクローンの同値類をクローンセットと呼ぶ．
%またクローンペアの2つのコード片に対し，それぞれを包含するいかなる字句列も等価でないとき，極大クローンペアと呼ぶ．
\par
本稿では，以下の3つのコードクローンの分類を用いる\cite{クローンタイプ}．
\begin{description}
    \item[Type-1クローン] 空白やタブの有無，括弧の位置などのコーディングスタイル，コメントの有無などの
違いを除き完全に一致するコードクローン
    \item[Type-2クローン] Type-1クローンの違いに加えて，変数名や関数名などのユーザ定義名，変数
の型などが異なるコードクローン
    \item[Type-3クローン] Type-2クローンの違いに加えて，文の挿入や削除，変更などが行われたコー
ドクローン
\end{description}



%瀬村らは，多様なプログラミング言語に容易に対応することができるコードクローン検出ツールの開発を目的として，構文解析器生成系の1つであるANTLRで利用される構文定義記述から，字句解析に必要な文法を自動的に抽出するモジュールを開発した\cite{CCFinderSW}．そしてこのモジュールが抽出した文法を用いて，言語の文法に沿ったコードクローン検出が可能なCCFinderSWを開発した．
%CCFinderSWは，Type-1およびType-2のコードクローンを検出できる．
%CCFinderSWの利用者は，構文定義記述が集められたリポジトリgrammars-v4\footnote{https://github.com/antlr/grammars-v4}から対象言語の構文定義記述を取得し，ツールの実行時に入力としてそのまま与えることでコードクローン検出を行うことができる．

従来，コードクローン検出ツールの対応言語を増加させることが困難であったが，瀬村らは多様なプログラミング言語に容易に対応できるコードクローン検出ツールCCFinderSWを開発した\cite{CCFinderSW}．CCFinderSWは，構文解析器生成系の1つであるANTLRで利用される構文定義記述から字句解析に必要な文法を自動的に抽出する．そして，抽出した文法に基づきType-2クローンを検出する．
CCFinderSWの利用者は，構文定義記述が集められたリポジトリgrammars-v4\footnote{https://github.com/antlr/grammars-v4}から対象言語の構文定義記述を取得し，ツールの実行時に入力として与えることで対応言語を増加させることができる．


\subsection{マイクロサービスとそのデータセット} \label{subsec:dataset}
マイクロサービスとはアプリケーションを小さな独立したサービスを組み合わせて構成するアーキテクチャである\cite{Honda2023,mo2021existence,zhao2022}．
その特徴として，サービス間の独立性，疎結合，データ分離を保ちながら開発とデプロイを行うことが挙げられる\cite{mo2021existence,zhao2022}．
これらの特徴が，アプリケーションのスケーラビリティと開発の迅速性をもたらしている．

%d'Aragonaらの研究では，World of Code\cite{WoC}からOSSのマイクロサービスを検索し，それを分類することでデータセットを作成した\cite{amoroso2024dataset}．

d'Aragonaらは，OSSリポジトリの大規模コレクションであるWorld of Code\cite{WoC}からマイクロサービスを採用した387個のプロジェクトを抽出し，データセットとして公開している\cite{amoroso2024dataset}．
%このデータセットのプロジェクトが満たす条件の一部を次に示す．
%\begin{itemize}
%    \item プロジェクトに100以上のコミットが含まれている．
%    \item プロジェクトに3人以上の貢献者が存在する．
%    \item リポジトリにDocker-Composeファイルが存在する．
%    \item プロジェクトが3つ以上のサービスで構成されている．
%    \item プロジェクトが12ヶ月以上活動している．
%\end{itemize}
%このようなマイクロサービスのOSSプロジェクトが，データセットに378個集められている．


\subsection{Javaにおけるマイクロサービスのコードクローンの調査}
%Moらの論文では，OSSのマイクロサービスプロジェクトに含まれるコードクローンを，サービス内とサービス間に分類し，コードクローンのタイプごとの違いや同時修正についての調査結果を報告している\cite{mo2021existence}．
%Moらの論文における同時修正の定義について説明する．
%バージョン$V_i$で検出されたクローンペアを$C_i$とする．
%バージョン$V_{i+1}$で，$V_i$における$C_i$が修正され，引き続きクローンペア$C_{i+1}$として検出されたとする．
%このとき，クローンペア$C_{i+1}$を同時修正が発生したクローンペアとしている．
%また，彼らがプロジェクトごとに定めた5バージョンを比較して同時修正かどうかを判断していた．

%Moら論文の調査結果によると，サービス内では57.1\%から91.7\%，サービス間では35.7\%から87.5\%がType-3コードクローンになっていた．
%さらに，サービス内では28.6\%から60.0\%，サービス間では14.3\%から63.6\%が同時修正が発生しているコードクローンになっていた．
%しかし，この調査には，以下のように課題点は3つある．
Moらは，OSSのマイクロサービスプロジェクトに含まれるType-1とType-2，Type-3クローンの存在とそれらの同時修正を調査した\cite{mo2021existence}．
彼らの調査では，バージョン$V_i$で検出されたクローンペアを$C_i$が修正され，$V_{i+1}$でクローンペア$C_{i+1}$として検出された場合，
クローンペア$C_{i+1}$を同時修正されたクローンペアと定義した．

彼らの調査結果によると，サービス内では57.1\%から91.7\%，サービス間では35.7\%から87.5\%の$LOC$がクローンになっている．
さらに，プロジェクトごとに5バージョンを比較した結果，サービス内では28.6\%から60.0\%，サービス間では14.3\%から63.6\%の$LOC$が同時修正されたクローンになっていた．

Moらの調査は，サービス内外のクローンペアを区別した分析を行っている点や，Type-3クローンを対象としている点において優れているが，その一方で以下に示す3つの問題点がある．
%\begin{itemize}
%    \item データセットに含まれているプロジェクトがすべてJavaで作成されている．
%    \item データセットに含まれているプロジェクトの数が8個である．
%    \item テストコードとプロダクトコードを区別していない．
%\end{itemize}
\begin{itemize}
    \item マイクロサービスでは，各サービスを独立して開発できるため，各サービスはJavaだけでなく様々な言語で開発されているにもかかわらず，調査対象のサービスがすべてJavaで開発されている．
    \item 調査対象のプロジェクトの数が8個のみである．
    \item テストコードに含まれるコードクローンの一部は，テストフレームワークが原因で生じると考えられるが，プロダクトコードに含まれるコードクローンと区別せず調査されていいる．
\end{itemize}

\section{予備調査} \label{sec:preliminary}
本章では，分析対象のプロジェクトや言語を選定するために実施した予備調査について説明する．

まず，\ref{subsec:dataset}節で説明したd'Aragonaらのデータセットには，リポジトリが現存しないプロジェクトが24個あったため，これらを全て除外した．
%プログラミング言語で記述されたプログラムが存在しないプロジェクト\footnote{DockerHub(\url{https://hub.docker.com/})のイメージをのみを利用してマイクロサービスを構成していた．}があったため，これらを分析から除外した．


%DockerHub\footnote{\url{https://hub.docker.com/}}のDockerイメージを利用してマイクロサービスを構成したプロジェクトが含まれている．しかし，これらのプロジェクトにはプログラミング言語で書かれたソースコードが存在しないため，分析対象から除外した．
次に，プロジェクトにおいて使用されているプログラミング言語を調査した\footnote{d'Aragonaらのデータセットには，各プロジェクトの使用言語の項目があるものの，一部のプロジェクトにおいて{\sf other}だけ記載されており使用言語を特定できないプロジェクトがあった．そのため本研究では，この項目は使用しなかった．}．
%この調査には，Gitリポジトリにおける使用言語を特定するためのライブラリであるGitHub Linguist\footnote{\url{https://github.com/github-linguist/linguist}}を使用した．
%しかし，この記載では一部のプログラミング言語がotherに分類されている．
%したがって，改めてプロジェクトに含まれているプログラミング言語を調査する必要がある．
%しかし，この記載では一部のプログラミング言語がotherに分類されているため，改めてプロジェクトに含まれているプログラミング言語を調査する必要がある．
%また，データセットに入っているプロジェクトの中には，DockerHub\footnote{\url{https://hub.docker.com/}}のDockerイメージを利用してマイクロサービスを構成しているものがある．
%この場合，ソースコードが取得できないため，分析の対象にできない．
%したがって，このようなプロジェクトを分析対象から除外する必要がある．
%この場合，ソースコードが取得できないため，分析の対象にできない
%そこで，本予備調査では，GitHub Linguist\footnote{\url{https://github.com/github-linguist/linguist}}を使用してプロジェクトに含まれている言語を調査した．
%GitHub Linguistは，GitHubで使われているGitリポジトリ内の言語を検出するライブラリである．
この調査は，以下の手順で実施した．
\begin{enumerate}
    \item データセットからソースコードを取得する．
    \item プロジェクトごとに得られたソースコードに対してGitHub Linguist\footnote{Gitリポジトリ中の使用言語を特定するライブラリ \url{https://github.com/github-linguist/linguist}}を実行する．
    \item 実行結果から各言語の$LOC$(Lines of Code)を計算．
    \item HTMLなどの非プログラミング言語を除外し，プロジェクトにおける使用言語比率を算出する．
\end{enumerate}
\begin{table}[tb]
    \centering
    \caption{検出対象のプログラミング言語}
    \label{table:detectLanguages}
    \begin{tabular}{c}
        \hline
        \verb|C/C++|, \verb|Java|, \verb|Perl|, \verb|PHP|, \verb|Python|, \verb|Ruby| \\
        \verb|Rust|, \verb|Scala|, \verb|Go|, \verb|JavaScript|, \verb|TypeScript|, \verb|C#| \\
        \hline
    \end{tabular}
\end{table}
%調査の過程で，リポジトリが存在しなかったプロジェクトが24個あったため，分析対象から除外した．

%この調査で得られた言語割合を元に，コードクローンを検出する言語を表\ref{table:detectLanguages}の言語に定めた．
この予備調査で得られた使用言語比率に基づき，本研究で対象する言語を表\ref{table:detectLanguages}のとおりに定めた．
GitHub\footnote{\url{https://github.com/YuichiSemura/CCFinderSW}}上で配布されているCCFinderSWはJavaScript，TypeScript，C\#に対応していなかったため，構文定義記述を追加することによってこれら言語に対応したCCFinderSWを本研究では用いた．
%この際CCFinderSWの初期設定で検出できる言語だけを対象にした場合，除外するプロジェクトが多かった．
%そこで，新たにJavaScript，TypeScript，C\#のコードクローンを検出できるように設定を変更した．

%また，データセットに入っているプロジェクトの中には，DockerHub\footnote{\url{https://hub.docker.com/}}のDockerイメージを利用してマイクロサービスを構成しているものがある．
%この場合，ソースコードが取得できないため，分析の対象にできない．
%したがって，このようなプロジェクトを分析対象から除外する必要がある．
%この場合，ソースコードが取得できないため，分析の対象にできない
%また，d'AragonaらのデータセットにはDockerHub\footnote{\url{https://hub.docker.com/}}のDockerイメージを利用してマイクロサービスを構成してプロジェクトが含まれている．しかし，これらのプロジェクトにはプログラミング言語で書かれたソースコードが存在しないため，分析対象から除外する必要がある．
%また，プログラミング言語で書かれたソースコードが存在しないプロジェクトと，ソースコード全体のうち検出対象の言語で書かれたソースコードの割合が95\%に満たないプロジェクト70個を分析対象から除外した．
%また，プログラミング言語で書かれたソースコードが存在しないプロジェクトと，ソースコード全体のうち検出対象の言語で書かれたソースコードの割合が95\%に満たないプロジェクト70個を分析対象から除外した．

最後に，プログラム全体のうち対象言語で書かれたプログラムの割合が95\%に満たないリポジトリが70個存在したため，これらを全て除外した．

予備調査の結果として，除外されなかった284個のプロジェクトを分析対象に設定した．


\section{分析} \label{sec:analysis}
%2.3節では，Moらの調査\cite{mo2021existence}に3つの課題点があることを示した．
%それを踏まえて，2.2節のOSSのマイクロサービスの多言語かつ大規模なデータセットに対して分析を行うことにした．
%これらより，RQを次の3つに定めた．
マイクロサービスにおけるクローン率や同時修正率に関して言語間比較を行うために，以下のRQを設定した．
%また，これらのRQに応えるために，３章と同様のデータセットに対して分析した．
\begin{description}
    \item[RQ1：] クローン率が高い言語はどれか？
    \item[RQ2：] プロダクトコードとテストコードでクローン率に違いがあるか？
    \item[RQ3：] コードクローンに対する同時修正率が高い言語はどれか？
\end{description}
言語ごとにテストフレームワークが異なることから，テストコードのクローン率や同時修正率が言語間で異なると考え，RQ2およびRQ3ではプロダクトコードとテストコードを分けて，分析を行った．
ファイルのパス名やファイル名に小文字大文字を区別なく{\sf test}が含まれていたら，そのファイルに含まれるプログラムは全てテストコードとして扱う．
それ以外のファイルは，全てプロダクトコードとして扱う．
また，あるクローンセットに含まれるコード片が1つ以上テストコードに含まれていたら，テストコードのクローンセットとする．
あるクローンセットに含まれるコード片が全てプロダクトコードに含まれていたら，プロダクトコードのクローンセットとする．

%1つテストコードに含まれていたら，テストコードのクローンセットとする．

%それぞれRQの設定の意図を説明する．
%まず，上記の各々のRQの動機を説明する．
%RQ1は言語ごとのクローンの割合の違いを分析するために設定した．
%RQ1は，言語ごとのクローンの割合の違いを明らかにするために設定した．
%これは，Moらの調査がJavaで開発されたマイクロサービスのみを調査対象にしているため，Java以外の言語で開発されたマイクロサービスも分析する必要があると考えたためである．
%RQ2はテストコードによるクローンの割合への影響を分析するために設定した．
%RQ2は，テストコードによるクローンの割合への影響を明らかにするために設定した．
%これは，Moらの調査では，テストによる結果への影響が考慮されていないことから，テストコードとプロダクトコードに分けて分析する必要があると考えたためである．
%これは，Moらの調査では，テストによる結果への影響が考慮されていないが，言語
%ごとにテストフレームワークが異なるため，テストコードのクローン率や同時修正率が言語間で異なると考え，プロダクトコードとテストコードを分
%けて，分析する必要があると考えたためである．
%また，本分析では，ファイルのパスおよびファイル名に小文字大文字を区別せずに「test」が含まれているものをテストコードが含まれているファイルとして扱い，テストのコード片が含まれないクローンセットをプロダクトコードのクローンセットとした．
%RQ3は言語ごとの同時修正率の違いを分析するために設定した．
%RQ3は，言語ごとの同時修正率の違いを明らかにするために分析するために設定した．
%これは，Moらの調査がJavaで開発されたマイクロサービスにおける同時修正されたクローンペアを調査していることから，Java以外の言語で開発されたマイクロサービスも分析する必要があると考えたためである．

\begin{figure*}
    \centering
    \includegraphics[width=0.8\linewidth]{images/overviewOfMethod.pdf}
    \caption{分析手法の概要}
    \label{fig:overviewOfMethod}
\end{figure*}

%次に，RQに回答するための分析手法の概要を図\ref{fig:overviewOfMethod}に示す．
%これより分析手法について説明する

%図\ref{fig:overviewOfMethod}はRQに回答するための分析手法の概要を示す．
%この図で示すように，最初に2.2節のデータセット\cite{amoroso2024dataset}からGitリポジトリのURLを取得し，GitHubからすべてのプロジェクトのソースコードを\verb|git clone|コマンドで取得する．
%この際，100コミット分のコミットデータも取得する．
次に，分析手法について説明する．本分析では，\ref{sec:preliminary}章で説明したとおり284個のプロジェクトを分析対象とする．
図\ref{fig:overviewOfMethod}はRQに回答するために実施する本研究の分析手法の概要を示す．
この図で示すように，d'AragonaらのデータセットからリポジトリのURLを取得し，\verb|git clone|コマンドを用いてGitHubから分析対象のプロジェクトの最新のソースコードを取得する．


%次に取得したソースコードに対して，2.1節で説明したCCFinderSWを用いて，表\ref{table:detectLanguages}にある分析対象の言語それぞれでコードクローンを検出する．
%このとき，予備実験で対象外となったプロジェクトは除外する．
次に，取得したソースコードに対して，CCFinderSWを用いてコードクローンを検出する．
このとき，CCFinderSWの設定は，検出範囲をファイル間に，出力形式をクローンセット，検出するコードクローンの最低トークン数(しきい値）をCCFinderSWのデフォルト値である50トークンに設定した．
検出範囲をファイル間にしたのは，よりマイクロサービスの特徴を示したコードクローンのみを検出するためである．


その後，本分析のために作成したプログラムがCCFinderSWの検出結果ファイルを読み込み，分析に情報を付加してデータベースに格納する．
%これより詳しく説明する．
%まず，CCFinderSWの言語ごとの検出結果が含まれるテキストファイルから，作成したプログラムがファイル情報とクローンセット情報に分ける．
%そのとき，まず，CCFinderSWの言語ごとの検出結果ファイルから，作成したプログラムがファイル情報とクローンセット情報に分ける．
%ファイル情報には，クローン率をファイルごとに算出して付け加える．
このとき，作成したプログラムがCCFinderSWの検出結果ファイルから，ファイル情報とクローンセット情報を取得し，それらの情報をデータベースに格納する．また，ファイルごとのクローン率情報もデータベースに格納する．本研究では，クローン率は$ROC(F)$の値を用いて計算する．
$ROC(F)$はファイル$F$がどの程度重複化しているかを表す指標である．$ROC(F)$は以下の式で計算される．
%Higoらの研究では，ファイル$F$がどの程度重複化しているかを表す指標として，$ROC(F)$を定義している\cite{HIGO2007985}．
%$F$の行数を$LOC(F)$，$F$の$LOC$のうちクローンセットに含まれている$LOC$を$LOC_{duplicated}(F)$とした場合，$ROC(F)$は以下の式で計算される．
\[ROC(F) = \frac{LOC_{duplicated}(F)}{LOC(F)}\]
上の式で，$LOC(F)$は$F$の行数を，$LOC_{duplicated}(F)$は$F$の$LOC$のうちクローンセットに含まれている$LOC$を示す．
これ以降では，$ROC(F)$をクローン率と呼ぶ．
また，クローンセット情報をデータベースに格納するとき，\verb|git blame|コマンドを用いて，クローンセットに含まれているコード片ごとに含まれるコミット情報を付け加える．
%それらの付け加えた情報を含めてクローンセット情報とファイル情報をそれぞれデータベースに格納する．

最後に，データベースに格納された情報を言語ごと，テストコードかプロダクトコードか同時修正されたクローンセットかどうかに基づいて分類し，各RQに回答する．
プロダクトコードとテストコードの区別は以下のとおりである．
\begin{itemize}
    \item ファイルのパス名やファイル名に小文字大文字を区別なく{\sf test}が含まれていたら，そのファイルに含まれるプログラムは全てテストコードとして扱う．
    \item それ以外のファイルは，全てプロダクトコードとして扱う．
\end{itemize}
また，クローンセットがプロダクトコードとテストコードのどちらであるかの判定基準は以下のとおりである．
\begin{itemize}
\item あるクローンセットに含まれるコード片が1つ以上テストコードに含まれていたら，テストコードのクローンセットとする．
\item それ以外（つまり，あるクローンセットに含まれるコード片が全てプロダクトコードに含まれていたら），プロダクトコードのクローンセットとする．
\end{itemize}
同時修正されたクローンセットは次の手順で判断する．この際，最新のコミットから100コミットを分析対象とした．
\begin{enumerate}
    \item クローンセットに含まれるコード片のコミット情報を取り出す．
    \item 最も古いコミットはないコミット番号をそれぞれ比較する．
    \item あるコード片のコミット番号が，クローンセット内の別のコード片に見られた場合，このクローンセットを同時修正されたクローンセットと判断する．
\end{enumerate}


\section{分析結果}

\subsection{RQ1: クローン率が高い言語はどれか？}
%本節の分析では，言語の，4章で説明したクローン率をプロジェクトごとに算出する．
%その後，算出した値を言語間で比較することで分析を行う．
このRQに応えるため，\ref{sec:analysis}章で定義したクローン率に基づき，プロジェクトごとに各言語の平均クローン率を算出し，算出した値を言語間で比較することで分析した．
\begin{figure*}[tb]
    \centering
    \includegraphics[width=11.0cm]{images/RQ1.pdf}
    \caption{言語ごとのクローン率の箱ひげ図}
    \label{fig:cloneRateByLanguages}
\end{figure*}
%
その分析結果を図\ref{fig:cloneRateByLanguages}に示す．
この図の縦軸はクローン率，横軸は言語を示す．
%また，この図の縦軸はクローン率で，横軸は言語である．

%これより，分析結果を説明する．
図\ref{fig:cloneRateByLanguages}が示すように，
クローン率の中央値が最も高かった言語は，C\#で40\%であった．
C\#に次いで、Javaが39\%、Goが35\%と高い値を示しました
一方，クローン率の中央値が最も低かった言語は，RubyとC/C++で，いずれも10\%であった．

\begin{itembox}[l]{RQ1への回答}
最もクローン率の中央値が高い言語はC\#で40\%であった．
%表現が微妙かも(太田)
2位と3位はJava，Goであり，それぞれ39\%，35\%であった．
%一方，最もクローン率の中央値が低い言語は，C/C++とRubyで10\%であった．
\end{itembox}

%クローンがテストコードである割合はどのくらいか？
\subsection{RQ2: プロダクトコードとテストコードでクローン率に違いがあるか？}

%本節では，プロダクトコードとテストコードでクローン率に違いがあるかを分析する．
%この分析は，各言語ごとにプロダクトコードとテストコードのクローン率をプロジェクト単位で算出することで行った．
このRQに応えるため，プロダクトコードとテストコードにおけるクローン率に違いがあるか，言語ごとに分析した．
\begin{figure*}[tb]
    \centering
    \includegraphics[width=\textwidth]{images/RQ2.pdf}
    \caption{テストコードとプロダクトコードにおける言語ごとのクローン率}
    \label{fig:cloneRateOfTestAndProduct}
\end{figure*}

\begin{table}[tb]
    \centering
    \caption{言語ごとのプロダクトコードとテストコードのLOCおよびプロジェクト数\\（各プロジェクトが複数言語に該当することがある）}
    \label{table:numberOfCloneSetCountByLabel}
    \begin{tabular}{|c|r|r|r|}
    \hline
    言語 & $LOC_p$ & $LOC_t$ & $N$\\
    \hline \hline
    Java & 2,745,122 & 1,222,774 & 78 \\
    \hline
    C/C++ & 398,927 & 57,260 & 13 \\
    \hline
    C\# & 564,648 & 15,729 & 20 \\
    \hline
    Go & 1,419,113 & 770,226 & 28 \\
    \hline
    JavaScript & 7,514,896 & 489,772 & 152 \\
    \hline
    Perl & 35,085 & 2,677 & 4 \\
    \hline
    PHP & 1,348,647 & 177,388 & 23 \\
    \hline
    Python & 2,298,816 & 1,517,369 & 88 \\
    \hline
    Ruby & 690,165 & 108,059 & 14 \\
    \hline
    Rust & 527,790 & 253,109 & 10 \\
    \hline
    Scala & 301,799 & 214,609 & 10 \\
    \hline
    TypeScript & 2,031,973 & 292,570 & 54 \\
    \hline \hline
    全体 & 19,876,981 & 5,121,542 & 284 \\
    \hline \hline
    \end{tabular}
\end{table}

テストコードとプロダクトコードの言語ごとのクローン率の分析結果を図\ref{fig:cloneRateOfTestAndProduct} に示す．
この図に示すように，プロダクトコードにおけるクローン率の中央値の上位3言語は，C\#，Java，Goで，それぞれ39\%，39\%，37\%であった．
テストコードでは，クローン率の中央値の上位3言語は，C\#，Java，PHPで，それぞれ37\%，37\%，29\%であった．C\#とJavaはプロダクトコードとテストコードの両方で高いクローン率を示した．

また，各言語ごとのプロジェクト数，および言語ごとのプロダクトコードとテストコードの$LOC$を表\ref{table:numberOfCloneSetCountByLabel}に示す．
この表では，$LOC_p$はプロジェクトコードの$LOC$の合計，$LOC_t$はテストコードの$LOC$の合計，$N$はプロジェクト数を示す．
また，プロジェクト数は1つのプロジェクトに複数の言語が含まれている場合がある．

最後に，プロダクトコードとテストコードにおけるクローン率の有意差を，有意水準5\%でマン・ホイットニーのU検定で確かめた．
その結果，GoとPythonでプロダクトコードとテストコードの間に有意な差が見られた．

%これより，図\ref{fig:cloneRateOfTestAndProduct}からわかることを説明する．
%プロダクトコードでは，クローン率の中央値の上位3件は，C\#，Java，Goで，それぞれ39\%，39\%，37\%であった．
%また，テストコードにおける，クローン率の中央値の上位3件は，C\#，Java，PHPで，それぞれ37\%，37\%，29\%であった．

\begin{itembox}[l]{RQ2への回答}
GoとPythonで，クローン率におけるプロダクトコードとテストコードの有意差が見られた．
したがって，一部の言語では，プロダクトコードとテストコードのクローン率が異なっているといえる．
\end{itembox}


%テストコードで含まれるクローンが修正されやすいか
\subsection{RQ3: コードクローンに対する同時修正率が高い言語はどれか？}
%本節では，コードクローンに対する同時修正率の言語ごとの違いを分析する．
%本分析における同時修正率は，同時修正が発生しているクローンセットの数を全体のクローンセットの数で割ったものである．
%また本節の分析は，テストコードとプロダクトコードを区別して行う．
このRQに応えるため，コードクローンに対する同時修正率が言語によって異なるか，テストコードとプロダクトコードを区別した分析した．
本分析における同時修正率は，同時修正されたクローンセットの数を全体のクローンセットの数で割ったものである．


\begin{figure*}[tb]
    \centering
    \includegraphics[width=\textwidth]{images/RQ3.pdf}
    \caption{プロダクトコードとテストコードにおける言語ごとの同時修正率}
    \label{fig:rateOfCoModifiedOfTestAndProduct}
\end{figure*}

分析結果を図\ref{fig:rateOfCoModifiedOfTestAndProduct}に示す．
この図では，縦軸にプロジェクトごとの同時修正率を示し，横軸に言語ごとにテストコードとプロダクトコードを分けて示している．
この図に示すように，
C\#の同時修正率の中央値が全言語で最も高く，71\%であった．
一方，C/C++とPerlの同時修正率の中央値が全言語で最も低く，1\%であった．
これらの結果から，言語によって同時修正率が異なっているとが明らかになった．
プロダクトコードにおける同時修正率の中央値の上位3件言語はC\#，TypeScript，Javaで，それぞれ76\%，38\%，36\%であった．
また，テストコードにおける同時修正率の中央値の上位3件言語はC\#，Java，Rubyで，それぞれ66\%，42\%，38\%であった．

最後に，プロダクトコードとテストコードにおける同時修正率の有意差を，有意水準5\%でマン・ホイットニーのU検定で確かめた．
その結果，TypeScriptでプロダクトコードとテストコードの間に有意な差が見られた．



\begin{itembox}[l]{RQ3への回答}
最も同時修正率の中央値が高かった言語はC\#で，71\%であった．
一方，最も同時修正率の中央値が低かった言語は，C/C++とPerlで，1\%であった．
したがって，言語によって同時修正率が異なっているといえる．
また，TypeScriptにおいて，プロダクトコードとテストコード間の同時修正率に有意差があった．
\end{itembox}

\section{考察}

\subsection{分析結果に対する考察}
本節では分析結果に対する考察を行う．

%まず，クローン率について，Moらの調査結果\cite{mo2021existence}と本分析の結果を比較する．
%Moらは，サービス内では57.1\%から91.7\%，サービス間では35.7\%から87.5\%がクローンになっていることを報告している．
%しかし，全体のクローンペアに対するType-2クローンペアの割合は，サービス内で11.9\%から27.0\%，サービス間で2.3\%から23.0\%であった．
%一方，本分析では，5.1節の分析結果によると，JavaにおけるType-2のクローン率の中央値は39\%であった．
%このことから，Moらの調査におけるType-2のクローン率よりも，本分析における Javaのクローン率は比較的高い結果であったといえる．

%次に，コードクローンに対する同時修正率について，Moらの調査結果と本分析の結果を比較する．
%はじめに，Moらの研究の調査と本分析では同時修正の定義が異なっていることを断っておく．
%Moらの研究の調査では過去5つのバージョンを比較しているが，本分析では最新のコードのコミット番号を比較している．
%同時修正の定義の違いを踏まえて，これより比較について述べる．
%Moらの調査では，サービス内では同時修正率が28.6\%から60.0\%，サービス間での同時修正率が14.3\%から63.6\%であること報告している．
%しかし，同時修正されたクローンペア全体に対するType-2クローンペアの割合はサービス内で0.0\%から40.0\%，サービス間で0.0\%から50.0\%であると報告されている．
%一方，本分析では，5.3節の分析結果によると，JavaプロダクトコードにおけるType-2クローンセットの同時修正率の中央値は36\%であった．
%このため，Moらの調査におけるType-2の同時修正率よりも，本分析におけるJavaの同時修正率は，比較的高い結果であったといえる．

%続いて，マイクロサービスでないプロジェクトのクローン率の調査と本分析の結果を比較する．
%Goonらの研究では，C/C++のプロジェクトにおけるコメントや空行を省いたクローン率が，おおよそ10\%以下に収まり，高くても18\%であったことが報告されている\cite{7880509}．
%一方，本分析では，5.1節の分析結果より，C/C++のクローン率の中央値は10\%で，最大値は25\%であった．
%ただし，本分析ではコメントや空行を省いておらず，コードクローンの検出範囲もファイル間であるため，クローン率はGoonらの研究結果と比べて高い数値が出ることが考えられる．
%したがって，マイクロサービスではクローン率が高くなる傾向があるといえる．

%次に，テストコードとプロダクトコードの違いについて考察する．
5.2節の分析結果では，GoとPythonにおいて，プロダクトコードとテストコードの間にクローン率に有意な差が見られた．
また，5.3節の分析結果では，TypeScriptにおいて，プロダクトコードとテストコードの間に同時修正率に有意な差が見られた．
これらの結果から，一部の言語では，テストコードが分析結果に影響を及ぼすといえる．
したがって，テストコードとプロダクトコードは分けて分析する必要がある．

分析結果より，どの言語のコードクローンが有害性が高いかを考察する．
コードクローンの存在はソフトウェアの保守性を低下させる原因の一つとして知られている．
しかし，すべてのコードクローンが保守コストを増大させるわけではない．
コードクローンに変更が発生した際に，変更が伝播することで保守性を低下させる．
既存研究では，プロジェクトの生存期間の間に一度も変更されない，あるいは定常的に変更されないコードクローンが存在することを示している\cite{balalaie2016migrating}\cite{svajlenko2014evaluating}．
したがって，クローン率と同時修正率が高い言語が保守性を低下させるため，有害性が高いといえる．
5.1節より，プロダクトコードでは，クローン率の中央値の上位3言語は，C\#，Java，Goで，それぞれ39\%，39\%，37\%であった．
また，5.3節より，プロダクトコードにおける，同時修正率の中央値の上位3言語はC\#，TypeScript，Javaで，それぞれ76\%，38\%，36\%であった．
これらの結果から，C\#とJavaのクローン率と同時修正率が共に高く，これらの言語のコードクローンの有害性が高いといえる．


\subsection{妥当性への脅威}
本節では分析結果の妥当性への脅威を考察する．

はじめに，コードクローン検出ツールについて考える．
本分析では多様なプログラミング言語に一様に対応するため，クローン検出ツールにCCFinderSWを用いた．
しかし，このツールではType-2までのコードクローンしか検出できない．
したがって，Type-3のコードクローンの分析は本分析では行っていない．

次にクローン検出範囲について考察する．
Moらの調査では，コードクローンをマイクロサービス内とサービス間に分類して調査を行っていた．
しかし，Moらの調査と比べ，本分析ではデータセットのプロジェクト数が増加したため，クローンセットをサービス間とサービス内のものに手動で分類することが困難であった\cite{mo2021existence}．
よって，本分析ではファイル間のクローンのみを検出することで，マイクロサービスの特性をより反映するようにした．
したがって，本分析の結果は，サービス内クローンおよびサービス間クローンについて調査した結果ではない．

最後に，自動生成コードについて考察する．
本分析ではテストコードとプロダクトコードを分けて分析している．
よって，テストコードの自動生成コードによる結果の変動は考えられている．
しかし，RPCシステムの一種であるgRPC\footnote{\url{https://grpc.io/}}や，オブジェクト指向言語のgetter/setterなどのプロダクトコードに含まれうる自動生成コードが存在する．
通常，自動生成コードの分類は，ソースコードのコメントの分類によって行われる．
今回の分析では，多数の言語の分析を行うため，その言語ごとに異なった手法で分類を行う必要がある．
したがって，本分析の結果には自動生成コードによる結果の変動は考えられていない．


\section{まとめ}
本稿では，Moらの調査結果を踏まえて，多言語かつ大規模なOSSのマイクロサービスのデータセットに対するコードクローンの分析を行った\cite{mo2021existence}．
予備調査ではデータセットのプロジェクトにどのような言語が含まれるかを調査した．
分析はプロジェクト数が多いデータセットに対して一様に処理を行い，RQごとに言語，テスト，同時修正の有無で分類することで行った．
その分析結果は，マイクロサービスでは言語ごと，テストコードとプロダクトコードでコードクローンが異なった性質を持つことを示した．
また，JavaとC\#のコードクローンが他の言語と比べ有害性が高いことも示した．

今後の展望として次のようなことが挙げられる．
\begin{description}
    \item[Type-3クローンの分析：] 
    Moらの調査ではType-3クローンを検出し調査を行っていた．しかし，本分析では，対象とする言語を増やしたことによって，それに対応できるType-3クローン検出ツールが存在しなかった．したがって，多言語のType-3クローン検出ツールが出た際の課題とする．
    \item[サービス内とサービス間に分類する：] 
    マイクロサービスでは，サービス間のコードクローンが独立性を脅かす．Moらの調査ではクローンペアをサービス内とサービス間に分類していた．しかし，本分析ではデータセットの規模が大きくなったことで分類が困難になり，行えなかった． そこで，大規模なデータセットにも対応可能な分類手法を考案することを今後の課題とする．
    \item[自動生成コードを分類する：] 
    自動生成コードがプロダクトコードのコードクローンの結果に影響を与えていることが考えられる．しかし，本分析では自動生成コードを分類した分析が行えていない．したがって，多言語なデータセットにも対応可能な自動生成コードの分類手法を考案することを今後の課題とする．
\end{description}

\bibliographystyle{jssst}
\bibliography{ref}

\end{document}